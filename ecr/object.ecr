<%= require_file(object.parent) -%>
<% object.interfaces.each do |interface| -%>
  <%= require_file(interface) %>
<% end %>

module <%= namespace_name %>
  <% if g_object_type? %>
  # :nodoc:
  annotation GeneratedWrapper
    # This annotation is used to identify user types that inherit from GObject from binding types that does the same.
  end
  <% end %>

  <% render_doc(object) -%>
  @[GObject::GeneratedWrapper]
  class <%= type_name %> <%= parent_class %>
    <% object.interfaces.each do |interface| -%>
    include <%= to_crystal_type(interface, namespace != interface.namespace) %>
    <% end %>

    @pointer : Pointer(Void)

    <% if g_object_type? %>
    macro inherited
      {% unless @type.annotation(GObject::GeneratedWrapper) %}
      # GType for the new created type
      @@_g_type : UInt64 = 0
      # Memory offset of `LibGICrystal::ObjectPrivate` inside the struct used for object instances, so
      # we can restore a `LibGICrystal::ObjectPrivate` pointer from a `GObject` pointer.
      @@_private_offset : Int32 = 0

      def self.g_type : UInt64
        if LibGLib.g_once_init_enter(pointerof(@@_g_type)) != 0
          g_type = {{ @type.superclass.id }}._register_derived_type({{ @type.id }},
            ->_class_init(Pointer(LibGObject::TypeClass), Pointer(Void)),
            ->_instance_init(Pointer(LibGObject::TypeInstance), Pointer(LibGObject::TypeClass)))

          @@_private_offset = LibGObject.g_type_add_instance_private(g_type, sizeof(LibGICrystal::ObjectPrivate))
          LibGLib.g_once_init_leave(pointerof(@@_g_type), g_type)
        end

        @@_g_type
      end

      # :nodoc:
      def self._class_init(klass : Pointer(LibGObject::TypeClass), user_data : Pointer(Void)) : Nil
        # At class initialization (from GObject point of view) we need to calculate the private offset, so we
        # can later restore `LibGICrystal::ObjectPrivate` from `GObject` pointers.
        LibGObject.g_type_class_adjust_private_offset(klass, pointerof(@@_private_offset)) if @@_private_offset != 0
      end

      # :nodoc:
      def self._instance_init(instance : Pointer(LibGObject::TypeInstance), type : Pointer(LibGObject::TypeClass)) : Nil
        private_obj = _private_object(instance.as(Pointer(Void)))
        private_obj.value.gc_collected = 0
        private_obj.value.crystal_instance_address = 0_u64
      end

      # :nodoc:
      def self._private_object(instance : Pointer(Void)) : Pointer(LibGICrystal::ObjectPrivate)
        # Retore our beloved `LibGICrystal::ObjectPrivate` from a `GObject` pointer.
        (instance + @@_private_offset).as(Pointer(LibGICrystal::ObjectPrivate))
      end

      def self.new
        instance = {{ @type.id }}.allocate
        gobj_ptr = LibGObject.g_object_newv({{ @type.id }}.g_type, 0, Pointer(Void).null)
        LibGObject.g_object_ref_sink(gobj_ptr) if LibGObject.g_object_is_floating(gobj_ptr) == 1

        private_obj = {{ @type.id }}._private_object(gobj_ptr)
        private_obj.value.crystal_instance_address = instance.object_id

        instance.initialize(gobj_ptr, :full)
        GC.add_finalizer(instance)
        instance
      end

      def initialize(pointer : Pointer(Void), transfer : GICrystal::Transfer)
        super
      end

      def finalize
        self.class._private_object(@pointer).value.gc_collected = 1
        super
      end

      # Cast a `GObject::Object` to this type, returns nil if cast can't be made.
      def self.cast?(obj : GObject::Object) : self?
        return if LibGObject.g_type_check_instance_is_a(obj, g_type).zero?

        private_obj = {{ @type.id }}._private_object(obj.to_unsafe)

        # If the object was collected by Crystal GC but still alive in C world we can't bring
        # the crystal object form the dead.
        raise GICrystal::ObjectCollectedError.new if private_obj.value.gc_collected != 0

        instance_address = private_obj.value.crystal_instance_address
        return Pointer({{ @type.id }}).new(instance_address).as({{ @type.id }}) unless instance_address.zero?

        # If the object was born in C world, crystal instance address still NULL
        # So we create a Crystal instance for it and annotate the crystal instance address
        # And if there's a float ref we sink it!
        LibGObject.g_object_ref_sink(obj) if LibGObject.g_object_is_floating(obj) == 1

        new_instance = {{ @type.id }}.new(obj.to_unsafe, :none)
        private_obj.value.crystal_instance_address = new_instance.object_id
        new_instance
      end
      {% end %}
    end

    <% end %>

    # :nodoc:
    def self._register_derived_type(klass : Class, class_init, instance_init)
      LibGObject.g_type_register_static_simple(g_type, klass.name,
                                               sizeof(<%= to_lib_type(object.class_struct) %>), class_init,
                                               sizeof(<%= to_lib_type(object) %>), instance_init, 0)
    end

    # :nodoc:
    def initialize(@pointer, transfer : GICrystal::Transfer)
      <% if object.parent.nil? %>
        LibGObject.<%= object.ref_function %>(self) unless transfer.full?
      <% else %>
        super
      <% end %>
    end

    <% if all_properties.any? -%>
      <% render "ecr/gobject_constructor.ecr" %>
    <% end %>

    <% if object.parent.nil? %>

      # Called by the garbage collector. Decreases the reference count of object.
      # (i.e. its memory is freed).
      def finalize
        {% if flag?(:debugmemory) %}
        LibC.printf("~%s at %p - ref count: %d\n", self.class.name.to_unsafe, self, ref_count)
        {% end %}
        LibGObject.<%= object.unref_function %>(self)
      end

      # Returns a pointer to the C object.
      def to_unsafe
        @pointer
      end

      <% render "ecr/cast_methods.ecr" %>
      <% render "ecr/ref_count_method.ecr" %>
    <% end %>

    <% render "ecr/g_type_method.ecr" %>
    <% render_properties %>
    <% render_methods %>
    <% render_signals %>
  end
end
