<% render_doc(obj, signal) -%>
struct <%= signal_type %>
  @source : GObject::Object
  @detail : String?

  def initialize(@source, @detail = nil)
  end

  def [](detail : String) : self
    raise ArgumentError.new("This signal already have a detail") if @detail
    self.class.new(@source, detail)
  end

  def name
    @detail ? "<%= signal.name %>::#{@detail}" : "<%= signal.name %>"
  end

  def connect(&block : Proc(<%= lean_proc_params %>))
    connect(block)
  end

  def connect_after(&block : Proc(<%= lean_proc_params %>))
    connect(block)
  end

  def connect(handler : Proc(<%= lean_proc_params %>))
    <% render_box(:lean_signal) %>
    LibGObject.g_signal_connect_data(@source, name, handler,
      GICrystal::ClosureDataManager.register(_box), ->GICrystal::ClosureDataManager.deregister, 0)
  end

  def connect_after(handler : Proc(<%= lean_proc_params %>))
    <% render_box(:lean_signal) %>
    LibGObject.g_signal_connect_data(@source, name, handler,
      GICrystal::ClosureDataManager.register(_box), ->GICrystal::ClosureDataManager.deregister, 1)
  end

  def connect(handler : Proc(<%= full_proc_params %>))
    <% render_box(:full_signal) %>
    LibGObject.g_signal_connect_data(@source, name, handler,
      GICrystal::ClosureDataManager.register(_box), ->GICrystal::ClosureDataManager.deregister, 0)
  end

  def connect_after(handler : Proc(<%= full_proc_params %>))
    <% render_box(:full_signal) %>
    LibGObject.g_signal_connect_data(@source, name, handler,
      GICrystal::ClosureDataManager.register(_box), ->GICrystal::ClosureDataManager.deregister, 1)
  end

  <%= signal_emit_method %>
end

def <%= to_method_name(signal.name) %>_signal
  <%= signal_type %>.new(self)
end
